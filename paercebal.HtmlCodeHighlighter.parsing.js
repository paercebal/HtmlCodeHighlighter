if(! typeof paercebal.HtmlCodeHighlighter.parsing !== 'undefined') { paercebal.HtmlCodeHighlighter.parsing = {} ; }




paercebal.HtmlCodeHighlighter.parsing.g_aKnownKeyword =
{
   // cssCodeMagicNumber
     "null"          : "cssCodeMagicNumber"
   , "NULL"          : "cssCodeMagicNumber"
   , "nullptr"       : "cssCodeMagicNumber"
   , "NULLPTR"       : "cssCodeMagicNumber"
   , "NULLREF"       : "cssCodeMagicNumber"
   
   // cssCodeKeyWord
   , "abstract"      : "cssCodeKeyWord"
   , "add"           : "cssCodeKeyWord"
   , "alias"         : "cssCodeKeyWord"
   , "as"            : "cssCodeKeyWord"
   , "ascending"     : "cssCodeKeyWord"
   , "asssert"       : "cssCodeKeyWord"
   , "auto"          : "cssCodeKeyWord"
   , "case"          : "cssCodeKeyWord"
   , "base"          : "cssCodeKeyWord"
   , "break"         : "cssCodeKeyWord"
   , "catch"         : "cssCodeKeyWord"
   , "checked"       : "cssCodeKeyWord"
   , "class"         : "cssCodeKeyWord"
   , "const"         : "cssCodeKeyWord"
   , "const_cast"    : "cssCodeKeyWord"
   , "constexpr"     : "cssCodeKeyWord"
   , "continue"      : "cssCodeKeyWord"
   , "debugger"      : "cssCodeKeyWord"
   , "declspec"      : "cssCodeKeyWord"
   , "decltype"      : "cssCodeKeyWord"
   , "default"       : "cssCodeKeyWord"
   , "delegate"      : "cssCodeKeyWord"
   , "delete"        : "cssCodeKeyWord"
   , "descending"    : "cssCodeKeyWord"
   , "do"            : "cssCodeKeyWord"
   , "dynamic"       : "cssCodeKeyWord"
   , "dynamic_cast"  : "cssCodeKeyWord"
   , "else"          : "cssCodeKeyWord"
   , "enum"          : "cssCodeKeyWord"
   , "event"         : "cssCodeKeyWord"
   , "explicit"      : "cssCodeKeyWord"
   , "export"        : "cssCodeKeyWord"
   , "extends"       : "cssCodeKeyWord"
   , "extern"        : "cssCodeKeyWord"
   , "false"         : "cssCodeKeyWord"
   , "final"         : "cssCodeKeyWord"
   , "finally"       : "cssCodeKeyWord"
   , "fixed"         : "cssCodeKeyWord"
   , "for"           : "cssCodeKeyWord"
   , "foreach"       : "cssCodeKeyWord"
   , "from"          : "cssCodeKeyWord"
   , "friend"        : "cssCodeKeyWord"
   , "function"      : "cssCodeKeyWord"
   , "get"           : "cssCodeKeyWord"
   , "global"        : "cssCodeKeyWord"
   , "goto"          : "cssCodeKeyWord"
   , "group"         : "cssCodeKeyWord"
   , "if"            : "cssCodeKeyWord"
   , "implicit"      : "cssCodeKeyWord"
   , "import"        : "cssCodeKeyWord"
   , "implements"    : "cssCodeKeyWord"
   , "in"            : "cssCodeKeyWord"
   , "inherits"      : "cssCodeKeyWord"
   , "inline"        : "cssCodeKeyWord"
   , "instanceof"    : "cssCodeKeyWord"
   , "interface"     : "cssCodeKeyWord"
   , "internal"      : "cssCodeKeyWord"
   , "into"          : "cssCodeKeyWord"
   , "is"            : "cssCodeKeyWord"
   , "join"          : "cssCodeKeyWord"
   , "let"           : "cssCodeKeyWord"
   , "lock"          : "cssCodeKeyWord"
   , "mutable"       : "cssCodeKeyWord"
   , "namespace"     : "cssCodeKeyWord"
   , "native"        : "cssCodeKeyWord"
   , "new"           : "cssCodeKeyWord"
   , "object"        : "cssCodeKeyWord"
   , "operator"      : "cssCodeKeyWord"
   , "orderby"       : "cssCodeKeyWord"
   , "out"           : "cssCodeKeyWord"
   , "override"      : "cssCodeKeyWord"
   , "package"       : "cssCodeKeyWord"
   , "params"        : "cssCodeKeyWord"
   , "partial"       : "cssCodeKeyWord"
   , "protected"     : "cssCodeKeyWord"
   , "private"       : "cssCodeKeyWord"
   , "public"        : "cssCodeKeyWord"
   , "readonly"      : "cssCodeKeyWord"
   , "ref"           : "cssCodeKeyWord"
   , "reinterpret_cast" : "cssCodeKeyWord"
   , "remove"        : "cssCodeKeyWord"
   , "return"        : "cssCodeKeyWord"
   , "sealed"        : "cssCodeKeyWord"
   , "select"        : "cssCodeKeyWord"
   , "set"           : "cssCodeKeyWord"
   , "sizeof"        : "cssCodeKeyWord"
   , "stackalloc"    : "cssCodeKeyWord"
   , "static"        : "cssCodeKeyWord"
   , "static_assert" : "cssCodeKeyWord"
   , "static_cast"   : "cssCodeKeyWord"
   , "strictfp"      : "cssCodeKeyWord"
   , "struct"        : "cssCodeKeyWord"
   , "super"         : "cssCodeKeyWord"
   , "switch"        : "cssCodeKeyWord"
   , "synchronized"  : "cssCodeKeyWord"
   , "template"      : "cssCodeKeyWord"
   , "this"          : "cssCodeKeyWord"
   , "throw"         : "cssCodeKeyWord"
   , "transient"     : "cssCodeKeyWord"
   , "true"          : "cssCodeKeyWord"
   , "try"           : "cssCodeKeyWord"
   , "typedef"       : "cssCodeKeyWord"
   , "typename"      : "cssCodeKeyWord"
   , "typeof"        : "cssCodeKeyWord"
   , "unchecked"     : "cssCodeKeyWord"
   , "unsafe"        : "cssCodeKeyWord"
   , "using"         : "cssCodeKeyWord"
   , "value"         : "cssCodeKeyWord"
   , "var"           : "cssCodeKeyWord"
   , "virtual"       : "cssCodeKeyWord"
   , "volatile"      : "cssCodeKeyWord"
   , "where"         : "cssCodeKeyWord"
   , "while"         : "cssCodeKeyWord"
   , "with"          : "cssCodeKeyWord"
   , "yield"         : "cssCodeKeyWord"


   // cssCodeType
   , "bool"          : "cssCodeType"
   , "boolean"       : "cssCodeType"
   , "byte"          : "cssCodeType"
   , "char"          : "cssCodeType"
   , "decimal"       : "cssCodeType"
   , "double"        : "cssCodeType"
   , "float"         : "cssCodeType"
   , "int"           : "cssCodeType"
   , "intptr_t"      : "cssCodeType"
   , "long"          : "cssCodeType"
   , "ptrdiff_t"     : "cssCodeType"
   , "sbyte"         : "cssCodeType"
   , "short"         : "cssCodeType"
   , "signed"        : "cssCodeType"
   , "size_t"        : "cssCodeType"
   , "ssize_t"       : "cssCodeType"
   , "string"        : "cssCodeType"
   , "uint"          : "cssCodeType"
   , "ulong"         : "cssCodeType"
   , "uintptr_t"     : "cssCodeType"
   , "unsigned"      : "cssCodeType"
   , "ushort"        : "cssCodeType"
   , "wchar_t"       : "cssCodeType"
   , "void"          : "cssCodeType"

   
   // cssCodeTypeWindows
   , "__declspec"    : "cssCodeKeyWord"
   , "dllimport"     : "cssCodeKeyWord"
   , "dllexport"     : "cssCodeKeyWord"
   , "BOOL"          : "cssCodeTypeWindows"
   , "TCHAR"         : "cssCodeTypeWindows"
   , "TRUE"          : "cssCodeMagicNumber"
   , "FALSE"         : "cssCodeMagicNumber"
   , "LONG"          : "cssCodeTypeWindows"
   , "INT"           : "cssCodeTypeWindows"
   , "LONG_PTR"      : "cssCodeTypeWindows"
   , "INT_PTR"       : "cssCodeTypeWindows"
   , "LRESULT"       : "cssCodeTypeWindows"
   , "HRESULT"       : "cssCodeTypeWindows"
   , "LPVOID"        : "cssCodeTypeWindows"
   , "LPSTR"         : "cssCodeTypeWindows"
   , "LPCSTR"        : "cssCodeTypeWindows"
   , "WPARAM"        : "cssCodeTypeWindows"
   , "LPARAM"        : "cssCodeTypeWindows"
   , "DWORD"         : "cssCodeTypeWindows"
   , "WORD"          : "cssCodeTypeWindows"
   
   // cssCodePreprocessor
   , "#if"           : "cssCodePreprocessor"
   , "#ifdef"        : "cssCodePreprocessor"
   , "#ifndef"       : "cssCodePreprocessor"
   , "#define"       : "cssCodePreprocessor"
   , "#include"      : "cssCodePreprocessor"
   , "#else"         : "cssCodePreprocessor"
   , "#elif"         : "cssCodePreprocessor"
   , "#endif"        : "cssCodePreprocessor"
   , "defined"       : "cssCodePreprocessor"
   , "#pragma"       : "cssCodePreprocessor"
   , "#error"        : "cssCodePreprocessor"
} ;



paercebal.HtmlCodeHighlighter.parsing.decorateKeyword = function(p_strKeyword)
{
   var strClass = paercebal.HtmlCodeHighlighter.parsing.g_aKnownKeyword[p_strKeyword] ;
   
   if(strClass)
   {
      return "\u003Cspan class=\"" + strClass + "\"\u003E" + p_strKeyword + "\u003C/span\u003E" ;
   }
   else
   {
      var fValue = parseFloat(p_strKeyword) ;
      
      if(! isNaN(p_strKeyword))
      {
         return "\u003Cspan class=\"cssCodeNumber\"\u003E" + p_strKeyword + "\u003C/span\u003E" ;
      }
   }
   
   return p_strKeyword ;
}











var K_TOKEN_SOURCE   = 0 ;
var K_TOKEN_CRLF     = 1 ;
var K_TOKEN_COMMENT  = 2 ;
var K_TOKEN_STRING   = 3 ;















paercebal.HtmlCodeHighlighter.parsing.CodeSourceToken = function(p_iType, p_strContent)
{
   this.m_iType            = p_iType ;
   this.m_strContent       = p_strContent ;
   this.m_strContentParsed = "" ;
}

paercebal.HtmlCodeHighlighter.parsing.CodeSourceToken.prototype.getWrappedToken = function()
{
   switch(this.m_iType)
   {
      case K_TOKEN_COMMENT :  return "\u003Cspan class=\"cssCodeComment\"\u003E" + this.m_strContentParsed + "\u003C/span\u003E" ;
      case K_TOKEN_STRING :   return "\u003Cspan class=\"cssCodeString\"\u003E" + this.m_strContentParsed + "\u003C/span\u003E" ;
      case K_TOKEN_CRLF :     return "\u000a" ;
      case K_TOKEN_SOURCE :
      default :               return this.m_strContentParsed ;
   }
}

paercebal.HtmlCodeHighlighter.parsing.CodeSourceToken.prototype.toDebug = function()
{
   switch(this.m_iType)
   {
      case K_TOKEN_COMMENT :  return "{ COMMENT : [" + this.m_strContent +  "] }" ;
      case K_TOKEN_STRING :   return "{ STRING  : [" + this.m_strContent +  "] }" ;
      case K_TOKEN_CRLF :     return "{ CRLF    }" ;
      case K_TOKEN_SOURCE :   return "{ SOURCE  : [" + this.m_strContent +  "] }" ;
      default :               return "{ UNKNOWN : [" + this.m_strContent +  "] }" ;
   }
}

paercebal.HtmlCodeHighlighter.parsing.CodeSourceToken.prototype.parse = function()
{
   if(this.m_iType == K_TOKEN_SOURCE)
   {
      var is = this.m_strContent ;
      var i = 0 ;
      var iCharCode = 0 ;
      var c ;
      var strResult = "" ;
      var iTabSize = document.getElementById("ID_tabulationSize").value ;
      var iWordStart = -1 ;
      var iWordEnd = -1 ;
      
      if(isNaN(iTabSize) || (iTabSize < 0)) { iTabSize == 3 ; }
      
      var fGenerateTab = function(p_iTabSize)
      {
         var strTempTab = "" ;
         
         while(p_iTabSize > 0)
         {
            strTempTab += " " ;
            p_iTabSize -= 1 ;
         }
         
         return strTempTab ;
      }
      
      var strTab = fGenerateTab(iTabSize) ;
      
      while(true)
      {
         if(i >= is.length) { break ; } ;
         
         c = is.charAt(i) ;
         
         switch(c)
         {
            case " " :
               {
                  if((iWordStart != -1) && (iWordStart < i))
                  {
                     // We do have a keyword
                     strResult += paercebal.HtmlCodeHighlighter.parsing.decorateKeyword(is.substring(iWordStart, i)) ;
                     iWordStart = -1 ;
                  }
                  
                  strResult += " " ;
                  ++i ;
               }
               break ;
            case "\u0001" : case "\u0002" : case "\u0003" : case "\u0004" : case "\u0005" :
            case "\u0006" : case "\u0007" : case "\u0008" :
            case "\u000b" : case "\u000c" : case "\u000e" : case "\u000f" :
            case "\u0010" : case "\u0011" : case "\u0012" : case "\u0013" : case "\u0014" :
            case "\u0015" : case "\u0016" : case "\u0017" : case "\u0018" : case "\u0019" :
            case "\u001a" : case "\u001b" : case "\u001c" : case "\u001d" : case "\u001e" : case "\u001f" :
               {
                  if((iWordStart != -1) && (iWordStart < i))
                  {
                     // We do have a keyword
                     strResult += paercebal.HtmlCodeHighlighter.parsing.decorateKeyword(is.substring(iWordStart, i)) ;
                     iWordStart = -1 ;
                  }
                  
                  //strResult += strTab ;
                  ++i ;
               }
               break ;
            case "\t" :
               {
                  if((iWordStart != -1) && (iWordStart < i))
                  {
                     // We do have a keyword
                     strResult += paercebal.HtmlCodeHighlighter.parsing.decorateKeyword(is.substring(iWordStart, i)) ;
                     iWordStart = -1 ;
                  }
                  
                  strResult += strTab ;
                  ++i ;
               }
               break ;
            case "*" :
            case "{" :
            case "}" :
            case "[" :
            case "]" :
            case "(" :
            case ")" :
            case "?" :
            case ";" :
            case "," :
            case "." :
            case "!" :
            case "&" :
            case "|" :
            case "=" :
            case "+" :
            case "-" :
            case "/" :
            case "^" :
            case "%" :
            case "\u003C" :
            case "\u003E" :
            case ":" :
               {
                  if((iWordStart != -1) && (iWordStart < i))
                  {
                     // We do have a keyword
                     strResult += paercebal.HtmlCodeHighlighter.parsing.decorateKeyword(is.substring(iWordStart, i)) ;
                     iWordStart = -1 ;
                  }
                  
                  if(is.charAt(i + 1) == c)
                  {
                     strResult += "\u003Cspan class=\"cssCodeOperator\"\u003E" + c + c + "\u003C/span\u003E" ;
                     i += 2;
                  }
                  else
                  {
                     strResult += "\u003Cspan class=\"cssCodeOperator\"\u003E" + c + "\u003C/span\u003E" ;
                     ++i ;
                  }
               }
               break ;
            default :
               {
                  if(iWordStart == -1)
                  {
                     // We do have a keyword
                     iWordStart = i ;
                  }
                  
                  ++i ;
               }
               break ;
         }
      }

      if((iWordStart != -1) && (iWordStart < is.length))
      {
         // We do have a keyword
         strResult += paercebal.HtmlCodeHighlighter.parsing.decorateKeyword(is.substring(iWordStart, is.length)) ;
      }

      this.m_strContentParsed = strResult ;
   }
   else
   {
      this.m_strContentParsed = this.m_strContent ;
   }
}








paercebal.HtmlCodeHighlighter.parsing.CodeSource = function(p_strOriginalSource)
{
   this.m_strOriginalSource = p_strOriginalSource ;
   this.m_strOriginalSourceNormalized = "" ;
   this.m_aToken = [] ;
   this.m_strHighlightedSource = "" ;
}

paercebal.HtmlCodeHighlighter.parsing.CodeSource.prototype.toHTML = function()
{
   return this.m_strHighlightedSource ;
}

paercebal.HtmlCodeHighlighter.parsing.CodeSource.prototype.addToken = function(p_iType, p_strContent)
{
   this.m_aToken.push(new paercebal.HtmlCodeHighlighter.parsing.CodeSourceToken(p_iType, p_strContent)) ;
}

paercebal.HtmlCodeHighlighter.parsing.CodeSource.prototype.addTokenCRLF = function()
{
   this.m_aToken.push(new paercebal.HtmlCodeHighlighter.parsing.CodeSourceToken(K_TOKEN_CRLF)) ;
}

paercebal.HtmlCodeHighlighter.parsing.CodeSource.prototype.addTokenSource = function(p_strContent)
{
   this.m_aToken.push(new paercebal.HtmlCodeHighlighter.parsing.CodeSourceToken(K_TOKEN_SOURCE, p_strContent)) ;
}

paercebal.HtmlCodeHighlighter.parsing.CodeSource.prototype.addTokenComment = function(p_strContent)
{
   this.m_aToken.push(new paercebal.HtmlCodeHighlighter.parsing.CodeSourceToken(K_TOKEN_COMMENT, p_strContent)) ;
}

paercebal.HtmlCodeHighlighter.parsing.CodeSource.prototype.addTokenString = function(p_strContent)
{
   this.m_aToken.push(new paercebal.HtmlCodeHighlighter.parsing.CodeSourceToken(K_TOKEN_STRING, p_strContent)) ;
}

paercebal.HtmlCodeHighlighter.parsing.CodeSource.prototype.parse = function()
{
   this.normalizeCRLF() ;
   this.tokenizeOriginalSource() ;
   this.parseTokens() ;
   this.mergeTokens() ;
}

// \t : \u0009
// \n : \u000a
// \v : \u000b
// \r : \u000d

paercebal.HtmlCodeHighlighter.parsing.CodeSource.prototype.normalizeCRLF = function()
{
   var is = this.m_strOriginalSource ;
   //is = is.replace("\u000d\u000a", "\u000a") ;
   //is = is.replace("\u000d", "\u000a") ;
   is = is.replace(/\x0d\x0a/g, "\u000a") ;
   is = is.replace(/\x0d/g, "\u000a") ;
   this.m_strOriginalSourceNormalized = is ;
}

paercebal.HtmlCodeHighlighter.parsing.CodeSource.prototype.parseTokens = function()
{
   var i, iMax ;
   
   for(i = 0, iMax = this.m_aToken.length; i < iMax; ++i)
   {
      this.m_aToken[i].parse() ;
   }
}

paercebal.HtmlCodeHighlighter.parsing.CodeSource.prototype.toDebug = function()
{
   var aS = [] ;
   var i, iMax ;
   
   for(i = 0, iMax = this.m_aToken.length; i < iMax; ++i)
   {
      aS.push(i + " : " + this.m_aToken[i].toDebug() + "\n") ;
   }
   
   return aS.join("") ;
}

paercebal.HtmlCodeHighlighter.parsing.CodeSource.prototype.mergeTokens = function()
{
   var buildF = function(p_iMaxLine)
   {
      var iPos = 0 ;
      var a = [] ;
      var b = true ;
      
      while(true)
      {
         a.push({ dec : iPos , str : "" , toString : function() { return "{ " + this.dec + ", [" + this.str + "] }" ; } }) ;
         
         if(iPos > p_iMaxLine) break ;
         if(iPos == 0) { iPos = 10 ; } else { iPos *= 10 ; }
      }
      
      var i, iMin, tab = "" ;
      
      for(i = a.length - 1, iMin = 0; i >= iMin; --i)
      {
         a[i].str = tab ;
         tab += " " ;
      }
      
      var f = function(p_iNumber)
      {
         if(a.length < 1)
         {
            return "" + p_iNumber ;
         }
      
         var i, iMax ;
         
         for(i = 0, iMax = a.length; i < iMax; ++i)
         {
            if(p_iNumber < a[i].dec)
            {
               return a[i].str + p_iNumber ;
            }
         }
         
         return "" + p_iNumber ;
      }
      
      return f ;
   } ;
/*
   var f = function(p_iNumber)
   {
      if(p_iNumber < 10)
      {
         return "   " + p_iNumber ;
      }
      else if(p_iNumber < 100)
      {
         return "  " + p_iNumber ;
      }
      else if(p_iNumber < 1000)
      {
         return " " + p_iNumber ;
      }
      return "" + p_iNumber ;
   }
*/

   var f = null ;
   var strFileName = document.getElementById("ID_fileName").value ;
   var iLine = parseInt(document.getElementById("ID_lineStart").value, 10) ;
   var aToken = [] ;
   var i, iMax ;
   var bIsFirst = true ;
   var wrappedToken ;
   var iMaxLine = iLine ;
   var isMagicBorder = true ;
   var leftBorder = paercebal.HtmlCodeHighlighter.highlighting.isBorderTooMuch() ? "" : "  " ;
   
   if(iLine < 0) { iLine = Number.NaN ; }
   
   if(! isNaN(iLine))
   {
      for(i = 0, iMax = this.m_aToken.length; i < iMax; ++i)
      {
         if(bIsFirst)
         {
            bIsFirst = false ;
            ++iMaxLine ;
         }

         if(this.m_aToken[i].m_iType == K_TOKEN_CRLF)
         {
            ++iMaxLine ;
         }
      }

      f = buildF(iMaxLine) ;
   }
   
   bIsFirst = true ;
   
   if(isMagicBorder)
   {
      aToken.push(leftBorder, "\n") ;
   }

   if(strFileName.length > 0)
   {
      if(isMagicBorder)
      {
         aToken.push(leftBorder) ;
      }

      aToken.push("\u003Cspan class=\"cssCodeLineFilenameHeader\"\u003EFilename: ", strFileName, "\u003C/span\u003E\n") ;

      if(isMagicBorder)
      {
         aToken.push(leftBorder) ;
      }

      aToken.push("\n") ;
   }

   for(i = 0, iMax = this.m_aToken.length; i < iMax; ++i)
   {
      if(bIsFirst)
      {
         if(isMagicBorder)
         {
            aToken.push(leftBorder) ;
         }

         bIsFirst = false ;
         if(! isNaN(iLine))
         {
            aToken.push("\u003Cspan class=\"cssCodeLineNumberPrefix\"\u003E", f(iLine), " |\u003C/span\u003E ") ;
            ++iLine ;
         }
         else
         {
            aToken.push("\u003Cspan class=\"cssCodeLineNumberPrefix\"\u003E", "\u003C/span\u003E") ;
         }
      }
      
      wrappedToken = this.m_aToken[i].getWrappedToken();
      aToken.push(wrappedToken) ;
      
      if(this.m_aToken[i].m_iType == K_TOKEN_CRLF)
      {
         if(isMagicBorder)
         {
            aToken.push(leftBorder) ;
         }

         if((i + 1) < iMax)
         {
            if(! isNaN(iLine))
            {
               aToken.push("\u003Cspan class=\"cssCodeLineNumberPrefix\"\u003E", f(iLine), " |\u003C/span\u003E ") ;
               ++iLine ;
            }
            else
            {
               aToken.push("\u003Cspan class=\"cssCodeLineNumberPrefix\"\u003E", "\u003C/span\u003E") ;
            }
         }
      }
   }
   
   if(isMagicBorder)
   {
      aToken.push(leftBorder, "\n") ;
   }
   
   this.m_strHighlightedSource = "\u003Cpre class=\"cssCode\"\u003E" + "\u003Cdiv class=\"cssCodeLine\"\u003E" ;

   this.m_strHighlightedSource += aToken.join("") ;
   this.m_strHighlightedSource += "\u003C/div\u003E" + "\u003C/pre\u003E" ;
   //this.m_strHighlightedSource = "\u003Cpre class=\"cssCode\"\u003E" + aToken.join("") + "\u003C/pre\u003E" ;
   //this.m_strHighlightedSource = "\u003Cpre class=\"cssCode\"\u003E" + "\u003Cstyle\u003E" + paercebal.HtmlCodeHighlighter.highlighting.getCodeStyle() + "\u003C/style\u003E" + aToken.join("") + "\u003C/pre\u003E" ;
}

paercebal.HtmlCodeHighlighter.parsing.CodeSource.prototype.tokenizeOriginalSource = function()
{
   var is = this.m_strOriginalSourceNormalized ;
   var i = 0 ;
   var iStart = 0, iEnd = 0 ;
   var c0, c1, c2, c3 ;
   var iState = K_TOKEN_SOURCE ;
   var bIsCharacterDefault ;
   
   while(true)
   {
      bIsCharacterDefault = false ;
      if(i >= is.length) { break ; }
      
      c0 = is.charAt(i) ;
      c1 = is.charAt(i + 1) ;
      
      switch(c0)
      {
      
         // COMMENT ============================================================
      
         case "/" :
            {
               switch(c1)
               {
                  case "/" :
                     {
                        this.addTokenSource(is.substring(iStart, i)) ;
                        iStart = i ;
                     
                        // C++ comment... Find the next "\n"
                        iEnd = is.indexOf("\u000a", i + 2) ;
                        
                        if(iEnd == -1)
                        {
                           iEnd = is.length ;
                        }
                        
                        this.addTokenComment(is.substring(iStart, iEnd)) ;
                        
                        i = iEnd ;
                        iStart = i ;
                     }
                     break ;
                  case "*" :
                     {
                        this.addTokenSource(is.substring(iStart, i)) ;
                        iStart = i ;
                        iEnd = i + 2 ;
                        
                        // C comment... Find the next "*/"
                        while(true)
                        {
                           if(iEnd >= is.length)
                           {
                              // This is the end (with an ERROR)
                              iEnd = is.length ;
                              break ;
                           }
                           
                           if(is.charAt(iEnd) == "\u000a")
                           {
                              this.addTokenComment(is.substring(iStart, iEnd)) ;
                              this.addTokenCRLF() ;
                              iStart = iEnd + 1 ;
                              iEnd = iStart ;
                              continue ;
                           }
                           
                           if((is.charAt(iEnd) == "*") && (is.charAt(iEnd + 1) == "/"))
                           {
                              iEnd += 2 ;
                              break ;
                           }
                           
                           ++iEnd ;
                        }
/*
                        iEnd = is.indexOf("\u002A/", i + 2) ;
                        
                        if(iEnd == -1)
                        {
                           // This is the end (with an ERROR)
                           iEnd = is.length ;
                        }
                        else
                        {
                           iEnd += 2 ;
                        }
*/
                        this.addTokenComment(is.substring(iStart, iEnd)) ;
                        
                        i = iEnd ;
                        iStart = i ;
                     }
                     break ;
                  default :
                     {
                        // Ignore because it is not a comment
                        bIsCharacterDefault = true ;
                     }
                     break ;
               }
            }
            break ;
      
         // QUOTE ============================================================
      
         case "\"" :
         case "\'" :
            {
               this.addTokenSource(is.substring(iStart, i)) ;
                     
               iStart = i ;
               iEnd = iStart + 1 ;
               var bIsEndOfQuoteFound = false ;
            
               while(! bIsEndOfQuoteFound)
               {
                  if(iEnd >= is.length)
                  {
                     iEnd = is.length ;
                     bIsEndOfQuoteFound = true ;
                     break ;
                  }
                  
                  c1 = is.charAt(iEnd) ;


                  if(c1 == "\u000a")
                  {
                     this.addTokenString(is.substring(iStart, iEnd)) ;
                     this.addTokenCRLF() ;
                     iStart = iEnd + 1 ;
                     iEnd = iStart ;
                     continue ;
                  }
                  else
                  {
                     switch(c1)
                     {
                        case "\\" :
                           {
                              if(iEnd < (is.length - 1))
                              {
                                 // this is an escape, so we go beyond it
                                 iEnd += 2 ;
                              }
                              else
                              {
                                 // this is the end (with an ERROR)
                                 iEnd = is.length ;
                                 bIsEndOfQuoteFound = true ;
                              }
                           }
                           break ;
                        case "\"" :
                        case "\'" :
                           {
                              if(c1 == c0)
                              {
                                 ++iEnd ;
                                 bIsEndOfQuoteFound = true ;
                              }
                              else
                              {
                                 ++iEnd ;
                              }
                           }
                           break ;
                        default :
                           {
                                 ++iEnd ;
                           }
                           break ;
                     }
                  }
               }
               
               this.addTokenString(is.substring(iStart, iEnd)) ;
               
               i = iEnd ;
               iStart = i ;
            }
            break ;
         default :
            {
               // Ignore because it is not a comment, nor a string
               bIsCharacterDefault = true ;
            }
            break ;
      }
      
      if(bIsCharacterDefault)
      {
         if(is.charAt(i) == "\u000a")
         {
            this.addTokenSource(is.substring(iStart, i)) ;
            this.addTokenCRLF() ;
            iStart = i + 1 ;
         }
      
         ++i ;
      }
   }
   
   if(iStart < i)
   {
      this.addTokenSource(is.substring(iStart, i)) ;
      this.addTokenCRLF() ;
   }
}
